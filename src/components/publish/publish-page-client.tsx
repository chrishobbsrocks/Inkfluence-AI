"use client";

import { useState, useCallback } from "react";
import { useRouter } from "next/navigation";
import { Loader2, Rocket } from "lucide-react";
import { Button } from "@/components/ui/button";
import { PrePublishChecklist } from "./pre-publish-checklist";
import { MetadataCard } from "./metadata-card";
import { PlatformManagementCard } from "./platform-management-card";
import { saveBookMetadataAction } from "@/server/actions/book-metadata";
import {
  connectPlatformAction,
  disconnectPlatformAction,
  updatePlatformStatusAction,
} from "@/server/actions/publishing-platforms";
import { usePublish } from "@/hooks/use-publish";
import type { PrePublishChecklistItem } from "@/types/book-metadata";
import type { BookMetadata } from "@/server/db/schema/book-metadata";
import type {
  PlatformCardData,
  PlatformStatus,
} from "@/types/publishing-platform";

export interface PublishPageClientProps {
  bookId: string;
  checklistItems: PrePublishChecklistItem[];
  metadata: BookMetadata | null;
  platforms: PlatformCardData[];
  templateId: string;
  allChecksPassed: boolean;
}

export function PublishPageClient({
  bookId,
  checklistItems,
  metadata: initialMetadata,
  platforms: initialPlatforms,
  templateId,
  allChecksPassed,
}: PublishPageClientProps) {
  const router = useRouter();
  const [metadata, setMetadata] = useState(initialMetadata);
  const [platforms, setPlatforms] = useState(initialPlatforms);
  const [isGenerating, setIsGenerating] = useState(false);
  const [isSaving, setIsSaving] = useState(false);

  const {
    status: publishStatus,
    progress,
    error: publishError,
    publishSelected,
  } = usePublish({ bookId, templateId });

  const isPublishing = publishStatus === "publishing";
  const selectedCount = platforms.filter(
    (p) => p.selected && p.connected
  ).length;
  const canPublish = allChecksPassed && selectedCount > 0 && !isPublishing;

  const handleGenerate = useCallback(async () => {
    setIsGenerating(true);
    try {
      const res = await fetch("/api/metadata/generate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ bookId }),
      });

      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || "Failed to generate metadata");
      }

      router.refresh();
      const data = await res.json();
      setMetadata((prev) => ({
        ...(prev ?? {
          id: data.metadataId,
          bookId,
          price: "9.99",
          createdAt: new Date(),
          updatedAt: new Date(),
        }),
        id: data.metadataId ?? prev?.id ?? "",
        bookId,
        description: data.description,
        keywords: data.keywords,
        category: data.category,
        descriptionAutoGenerated: true,
        keywordsAutoGenerated: true,
        categoryAutoGenerated: true,
        price: prev?.price ?? "9.99",
        createdAt: prev?.createdAt ?? new Date(),
        updatedAt: new Date(),
      }));
    } catch (err) {
      console.error("Metadata generation failed:", err);
    } finally {
      setIsGenerating(false);
    }
  }, [bookId, router]);

  const handleSave = useCallback(
    async (data: {
      description: string | null;
      keywords: string[];
      category: string | null;
      price: string;
      descriptionAutoGenerated: boolean;
      keywordsAutoGenerated: boolean;
      categoryAutoGenerated: boolean;
    }) => {
      setIsSaving(true);
      try {
        const result = await saveBookMetadataAction(bookId, data);
        if (!result.success) {
          console.error("Save failed:", result.error);
          return;
        }
        setMetadata((prev) => ({
          ...(prev ?? {
            id: result.data.id,
            bookId,
            createdAt: new Date(),
          }),
          id: result.data.id ?? prev?.id ?? "",
          bookId,
          description: data.description,
          keywords: data.keywords,
          category: data.category,
          price: data.price,
          descriptionAutoGenerated: data.descriptionAutoGenerated,
          keywordsAutoGenerated: data.keywordsAutoGenerated,
          categoryAutoGenerated: data.categoryAutoGenerated,
          updatedAt: new Date(),
          createdAt: prev?.createdAt ?? new Date(),
        }));
        router.refresh();
      } catch (err) {
        console.error("Save failed:", err);
      } finally {
        setIsSaving(false);
      }
    },
    [bookId, router]
  );

  const handleConnect = useCallback(
    async (code: string) => {
      const result = await connectPlatformAction({
        bookId,
        platformCode: code,
      });
      if (result.success) {
        router.refresh();
        setPlatforms((prev) =>
          prev.map((p) =>
            p.code === code
              ? { ...p, connected: true, id: result.data.id }
              : p
          )
        );
      }
    },
    [bookId, router]
  );

  const handleDisconnect = useCallback(
    async (code: string) => {
      const result = await disconnectPlatformAction(bookId, code);
      if (result.success) {
        router.refresh();
        setPlatforms((prev) =>
          prev.map((p) =>
            p.code === code
              ? { ...p, connected: false, selected: false }
              : p
          )
        );
      }
    },
    [bookId, router]
  );

  const handleToggleSelect = useCallback((code: string) => {
    setPlatforms((prev) =>
      prev.map((p) =>
        p.code === code ? { ...p, selected: !p.selected } : p
      )
    );
  }, []);

  const handleStatusChange = useCallback(
    async (code: string, status: PlatformStatus) => {
      const result = await updatePlatformStatusAction({
        bookId,
        platformCode: code,
        status,
      });
      if (result.success) {
        router.refresh();
        setPlatforms((prev) =>
          prev.map((p) => (p.code === code ? { ...p, status } : p))
        );
      }
    },
    [bookId, router]
  );

  const handlePublish = useCallback(() => {
    publishSelected(platforms);
  }, [platforms, publishSelected]);

  return (
    <div className="flex-1 bg-stone-50/50 p-5 overflow-y-auto">
      <PrePublishChecklist bookId={bookId} items={checklistItems} />

      {/* Publish action bar */}
      <div className="mt-4 flex items-center justify-between">
        <div className="text-xs text-stone-500">
          {selectedCount > 0
            ? `${selectedCount} platform${selectedCount > 1 ? "s" : ""} selected`
            : "Select platforms to publish"}
        </div>
        <Button
          size="sm"
          className="h-8 text-xs bg-stone-900 hover:bg-stone-800 gap-1.5"
          disabled={!canPublish}
          onClick={handlePublish}
        >
          {isPublishing ? (
            <Loader2 className="w-3 h-3 animate-spin" />
          ) : (
            <Rocket className="w-3 h-3" />
          )}
          {isPublishing
            ? "Publishing..."
            : `Publish to ${selectedCount > 0 ? selectedCount : "All"} Selected`}
        </Button>
      </div>

      {/* Publishing progress banner */}
      {isPublishing && progress.currentPlatform && (
        <div className="mt-3 p-3 bg-stone-900 text-white rounded-lg flex items-center gap-3">
          <Loader2 className="w-4 h-4 animate-spin flex-shrink-0" />
          <div className="text-xs">
            <span className="font-medium">
              Publishing to {progress.currentPlatform}
            </span>
            <span className="text-stone-400 ml-2">
              ({progress.completed + 1}/{progress.total}) â€”{" "}
              {progress.currentStep === "export"
                ? "Generating file..."
                : progress.currentStep === "metadata"
                  ? "Downloading metadata..."
                  : "Updating status..."}
            </span>
          </div>
        </div>
      )}

      {publishError && (
        <div className="mt-3 p-3 bg-red-50 border border-red-200 rounded-lg text-xs text-red-700">
          {publishError}
        </div>
      )}

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 mt-4">
        <MetadataCard
          metadata={metadata}
          onGenerate={handleGenerate}
          onSave={handleSave}
          isGenerating={isGenerating}
          isSaving={isSaving}
        />
        <PlatformManagementCard
          platforms={platforms}
          onConnect={handleConnect}
          onDisconnect={handleDisconnect}
          onToggleSelect={handleToggleSelect}
          onStatusChange={handleStatusChange}
          disabled={isPublishing}
        />
      </div>
    </div>
  );
}
